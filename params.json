{"name":"Chameleon","tagline":"","body":"![logo](https://github.com/JJaraM/Chameleon/blob/master/logo.png)\r\n\r\n# What is Chameleon?\r\nIs a java framework that helps the copy objects that have the same attributes types, without the necessity to create heavy factories and deal with the creation of the subrelations objects. \r\n\r\n# Problem to attack \r\n\r\nFor example **Chameleon** will prevent this.\r\n\r\n```java\r\npublic class CarFactory {\r\n\r\n     public static CarFactory instance = null;\r\n\r\n     public static CarFactory getInstance() {\r\n          if (instance == null) {\r\n               instance = new CarFactory();\r\n          }\r\n          return instance;\r\n     }\r\n\r\n     public CarDTO create(Car car) {\r\n          Motor motor = MotorFactory.getInstance().create(car.getMotor()); // First factory created because we have a relation\r\n          MotorDTO motorDTO = new MotorDTO(); // Object from relation\r\n          motorDTO.setId(motor.getId());\r\n          CarDTO carDTO = new CarDTO(); \r\n          carDTO.setModel(car.getModel()); \r\n          carDTO.setYear(car.getYear());\r\n          carDTO.setMotor(motorDTO);\r\n          return carDTO;\r\n     }\r\n}\r\n```\r\n\r\nRepresentation of MotorFactory class.\r\n\r\n```java\r\npublic class MotorFactory {\r\n\r\n     public static MotorFactory instance = null;\r\n\r\n     public static MotorFactory getInstance() {\r\n          if (instance == null) {\r\n               instance = new MotorFactory();\r\n          }\r\n          return instance;\r\n     }\r\n\r\n     public MotorDTO create(Motor motor) {\r\n          MotorDTO motorDTO = new MotorDTO();\r\n          motorDTO.setId(motor.getId());\r\n          return motorDTO;\r\n     }\r\n}\r\n```\r\n\r\nIn the previous example we are creating a new CarDTO, maybe we want to return this value from an API and hide some fields, this scenario is the most common, we create a factory for each class, but this work can be boring and very difficult to give support, **why?**, imagine the next scenario; we want to display the all cars but we need to display only the model and we need to hide the year. Many people creates a new method in CarFactory and pass the object but ignore the line.\r\n\r\n```java\r\npublic class CarFactory {\r\n\r\n     public static CarFactory instance = null;\r\n\r\n     public static CarFactory getInstance() {\r\n          if (instance == null) {\r\n               instance = new CarFactory();\r\n          }\r\n          return instance;\r\n     }\r\n\r\n     public CarDTO create(Car car) {\r\n          Motor motor = MotorFactory.getInstance().create(car.getMotor()); // First factory created because we have a relation\r\n          MotorDTO motorDTO = new MotorDTO(); // Object from relation\r\n          motorDTO.setId(motor.getId());\r\n          CarDTO carDTO = new CarDTO(); \r\n          carDTO.setModel(car.getModel()); \r\n          carDTO.setYear(car.getYear());\r\n          carDTO.setMotor(motorDTO);\r\n          return carDTO;\r\n     }\r\n     \r\n       public CarDTO createWithoutYear(Car car) {\r\n          car.setYear(null);\r\n          return create(car);\r\n     }\r\n}\r\n```\r\n\r\nAs you can see we are adding a little of complexity to our factory, because can be many of possiblities, and each posiblity means a new method.\r\n\r\n# How **chameleon** will solved this problem?\r\n\r\nAs you saw in the last section we had the problem to create to many methods in a factory, the propose to chameleon is manage this creation using a similar sintax as SQL, we can use this query and select the fields that we want and ignore the all complexity of object creation.\r\n\r\n```java\r\npublic interface PlaceDTORepository {\r\n     @Query(\"SELECT C.model, C.year, C.id, M.id FROM Car c JOIN Motor M\")\r\n     Set<PlaceDTO> fetchCollection(Set<Car> cars);\r\n}\r\n```\r\n\r\nAs you saw the only thing that we need is to create a simple interface, add the expected result and the columns that we want to display.\r\n\r\n```java\r\npublic interface CarDTORepository {\r\n     @Query(\"SELECT C.model, C.year, C.id, M.id FROM Car c JOIN Motor M\")\r\n     Set<PlaceDTO> fetchCollection(Set<Car> cars);\r\n    \r\n     @Query(\"SELECT C.model, C.id, M.id FROM Car c JOIN Motor M\")\r\n     Set<PlaceDTO> fetchCollectionWithoutCarYear(Set<Car> cars);\r\n}\r\n```\r\n\r\nAnd to call out repository we need to inject our class in the desire place.\r\n\r\n```java\r\npublic class PlaceController {\r\n\r\n     @Resource private CarDTORepository carDTORepository;\r\n     \r\n     public Set<PlaceDTO> getList() {\r\n          Set<Car> cars = someMethodRetrieveAJPACollection(...);\r\n          return carDTORepository.fetchCollection(cars);\r\n     }\r\n}\r\n```\r\n\r\nAs you can see we are not working any more with factories, and the Chameleon framework deal with the object creations.\r\n\r\n# Dependencies\r\n\r\n* spring-aop 4.2.5.RELEASE\r\n* spring-beans 4.2.4.RELEASE\r\n* spring-context 4.2.4.RELEASE\r\n* spring-aop 4.2.5.RELEASE\r\n* aspectjweaver 1.8.8\r\n* aspectjrt 1.8.8\r\n* hibernate-core 5.1.0.Final\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}